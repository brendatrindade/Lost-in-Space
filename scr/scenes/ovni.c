#include "proc_grafico.h"
#include "../joguinho/scr/acelerometro.c"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define largura_sprite 20
#define altura_sprite 20

//Dados da imagem para formar um sprite (20x20) em formato RRRGGGBB - 1 byte por pixel
uint8_t dados_da_imagem[altura_sprite][largura_sprite] = {
{ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
{ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x96,0x76,0x76,0x96,0xdb,0xff,0xff,0xff,0xff,0xff,0xff,0xff },
{ 0xff,0xff,0xff,0xff,0xff,0xff,0xdb,0x76,0xbf,0x7f,0x7f,0x7f,0x7b,0xbb,0xff,0xff,0xff,0xff,0xff,0xff },
{ 0xff,0xff,0xff,0xff,0xff,0xff,0x76,0xdf,0xff,0x9f,0x7f,0x7f,0x7f,0x76,0xff,0xff,0xff,0xff,0xff,0xff },
{ 0xff,0xff,0xff,0xff,0xb6,0x4d,0x7b,0xdf,0xbf,0x7f,0x7f,0x7f,0x7f,0x7f,0x49,0x92,0xdb,0xff,0xff,0xff },
{ 0xff,0xff,0x96,0x49,0x96,0x29,0x7b,0x9f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x29,0x96,0x4d,0x71,0xff,0xff },
{ 0xff,0x96,0x72,0x97,0x96,0x4d,0x51,0x56,0x7f,0x7f,0x7f,0x7f,0x57,0x31,0x4d,0x96,0x97,0x72,0x76,0xff },
{ 0xdb,0x35,0x97,0x97,0x96,0x4e,0x49,0x2d,0x51,0x2d,0x2d,0x4d,0x29,0x4d,0x49,0x92,0x97,0x97,0x35,0xb6 },
{ 0x96,0x35,0x96,0x72,0x6e,0x96,0x6e,0x49,0x29,0x29,0x29,0x29,0x29,0x6e,0x92,0x72,0x6e,0x96,0x35,0x76 },
{ 0x96,0x35,0x2d,0x92,0x97,0x97,0x97,0x96,0x92,0x72,0x72,0x72,0x92,0x97,0x97,0x97,0x96,0x4d,0x35,0x72 },
{ 0xb6,0x2d,0x35,0x55,0x76,0x76,0x72,0x97,0x97,0x92,0x96,0x97,0x97,0x72,0x76,0x96,0x55,0x35,0x2d,0x92 },
{ 0xff,0x29,0x31,0x35,0x35,0x59,0x76,0x96,0x96,0x92,0x96,0x96,0x96,0x76,0x59,0x35,0x35,0x35,0x29,0xdb },
{ 0xff,0xba,0x79,0x31,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x31,0x75,0xba,0xff },
{ 0xff,0xdb,0x99,0x55,0x29,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x29,0x51,0x99,0xbb,0xff },
{ 0xff,0x97,0x96,0x96,0x72,0x79,0x99,0x2d,0x29,0x55,0x59,0x2d,0x2d,0x79,0x79,0x76,0x96,0x96,0x97,0xff },
{ 0xff,0xb7,0x97,0x97,0x96,0x96,0x51,0x25,0x25,0x51,0x75,0x25,0x25,0x51,0x96,0x96,0x97,0x97,0x97,0xff },
{ 0xff,0xdb,0x97,0x97,0x97,0x97,0x97,0x96,0x96,0x92,0x72,0x96,0x96,0x97,0x97,0x97,0x97,0x97,0xdb,0xff },
{ 0xff,0xff,0xdb,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0xbb,0xff,0xff },
{ 0xff,0xff,0xff,0xff,0xdb,0xb7,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0xb7,0xbb,0xff,0xff,0xff,0xff },
{ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xdf,0xdf,0xdb,0xdb,0xdf,0xdf,0xff,0xff,0xff,0xff,0xff,0xff,0xff }
};


//Converte os dados da imagem de RGB para BGR 9 bits - formato da instrucao wsm
uint16_t converte_em_bgr(uint8_t rgb) {
    uint8_t r, g, b;
    uint16_t bgr;

    //Extrai cada tom (R, G e B) do formato RGB
    r = (rgb >> 5) & 0b111; // 3 bits msb do vermelho
    g = (rgb >> 2) & 0b111; // 3 bits do meio do verde
    b = rgb & 0b11; // 2 bits lsb do azul
    //ajusta o azul de 2 para 3 bits
    b = b << 1;

    //Coloca no formato BBB GGG RRR de 9 bits
    bgr = ( (b << 6) | (g << 3) | r );

    return bgr;
}

//Cria e armazena um sprite na memoria de sprites
void cria_sprite(uint16_t end_base, uint16_t dados_do_sprite[altura_sprite][largura_sprite]) {
    uint16_t cor[400]; //20x20 -> 400 pixels por sprite
    int y, x;
    int z = 0;
    for ( y = 0; y < altura_sprite; y++) {
        for ( x = 0; x < largura_sprite; x++) {
            cor[z] = dados_do_sprite[y][x]; //Extrai a cor de cada pixel em 9 bits BGR
            z++;
        }
    }
    //Escreve cada pixel da matriz 20x20 na memoria de sprites
    int i = 0;
    while (i < 400){
        altera_pixel_sprite(cor[i], end_base + i);
        i++;
        usleep(10000);
    }
}

//Exibe e move um sprite armazenado na memoria de sprites pela tela
void move_sprite() {
    #define mascara_10bits 0b1111111111
    uint16_t pos_x = 350;
    uint16_t pos_y = 240;

    pos_x &= mascara_10bits;
    pos_y &= mascara_10bits;
    
    uint32_t pos_xy_20b;
    pos_xy_20b = (pos_x << 10 | pos_y);
    uint32_t pos_xy_20b_ant = (pos_xy_20b); //inicia com posicao anterior igual a posicao atual

    int direcao_sprite = 1; //1 descendo e -1 subindo
    int i = 0;

    while (i < 1000) {
        //apaga o sprite exibido na posicao anterior
        exibe_sprite(0, pos_xy_20b_ant, 5, 1);//sp = 0 - desabilita sprite
        pos_xy_20b_ant = pos_xy_20b;
    
        //exibe o sprite na posicao atual
        exibe_sprite(1, pos_xy_20b, 5, 1);//sp = 1 - habilita sprite

        //verifica os limites da tela para ajustar a direcao
        //tela 640 x 480
        if (direcao_sprite == 1 && (pos_xy_20b < 358850) ){
            pos_xy_20b+= 10;//posicao atual + 10
            if(pos_xy_20b == 358850){
                //101011110 0111000010 -> x = 0101011110 = 350, y = 0111000010 = 450
                direcao_sprite = -1;
            }
        }

        else if (direcao_sprite == -1 && (pos_xy_20b > 358410) ){
            pos_xy_20b-=10;//posicao atual - 10
            if(pos_xy_20b == 358410){
                //0101011110 0000001010 -> x = 0101011110 = 350, y = 0000001010 = 10
                direcao_sprite = 1;
            }
        }
        usleep(10000);
        i++;
    }
}


//Exibe e move um sprite armazenado na memoria de sprites pela tela controlado pelo acelerometro
void move_sprite_acel() {
 #define mascara_10bits 0b1111111111
    uint16_t pos_x = 350;
    uint16_t pos_y = 240;

    pos_x &= mascara_10bits;
    pos_y &= mascara_10bits;
    
    uint32_t pos_xy_20b;
    pos_xy_20b = (pos_x << 10 | pos_y);
    uint32_t pos_xy_20b_ant = (pos_xy_20b); //inicia com posicao anterior igual a posicao atual

    int direcao_y_sprite = -get_direcao_movimento_y(); //1 descendo e -1 subindo

    int i = 0;

    while (i != -1) {
        //apaga o sprite exibido na posicao anterior
        exibe_sprite(0, pos_xy_20b_ant, 5, 1);//sp = 0 - desabilita sprite
        pos_xy_20b_ant = pos_xy_20b;
    
        //exibe o sprite na posicao atual
        exibe_sprite(1, pos_xy_20b, 5, 1);//sp = 1 - habilita sprite

        //verifica os limites da tela para ajustar a direcao
        //tela 640 x 480
        if (direcao_y_sprite == 1 && (pos_xy_20b < 358850) ){
            pos_xy_20b+= 10;//posicao atual + 10
            if(pos_xy_20b == 358850){
                //101011110 0111000010 -> x = 0101011110 = 350, y = 0111000010 = 450
                //direcao_y_sprite = -1;
                pos_xy_20b == 358850; //fica no limite da tela
            }
        }

        else if (direcao_y_sprite == -1 && (pos_xy_20b > 358410) ){
            pos_xy_20b-=10;//posicao atual - 10
            if(pos_xy_20b == 358410){
                //0101011110 0000001010 -> x = 0101011110 = 350, y = 0000001010 = 10
                //direcao_y_sprite = 1;
                pos_xy_20b == 358410; //fica no limite da tela
            }
        }
        usleep(10000);
        i++;
    }
}